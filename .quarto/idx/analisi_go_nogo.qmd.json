{"title":"HSAM: Analisi Go-NoGo","markdown":{"yaml":{"title":"HSAM: Analisi Go-NoGo","author":"Lorenzo Atzeni","format":{"html":{"code":false,"theme":"flatly","self-contained":true}},"editor":"visual"},"headingText":"Pre-processing, data cleaning","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)\n```\n\n\nHo applicato una procedura simile a quella del dataframe del matching task, selezionando solo trial eseguiti correttamente (accuratezza=1) della condizione go. Inoltre ho escluso tempi di reazione estremi, definiti come valori oltre ±3 deviazioni standard dalla media per ciascun partecipante e condizione.\n\n```{r, echo=FALSE}\nlibrary(knitr)\n\ndf_go <- read.csv(\"C:/Users/39348/Desktop/DATI/go_unificato.csv\", stringsAsFactors = FALSE)\nx <- table(df_go$id_subj, df_go$block_order)\n\n# Prendi head e tail\nhx <- head(x)\ntx <- tail(x)\n\n# Costruzione tabella affiancata senza duplicazioni\ntabella_affiancata <- cbind(\n  ID_CNTRL = rownames(hx),\n  hx,\n  ID_HSAM = rownames(tx),\n  tx\n)\n\n# Stampa la tabella\nkable(tabella_affiancata,\n      caption = \" trial per CNTRL (head) e HSAM (tail)\",\n      align = rep(\"c\", ncol(tabella_affiancata)))\n\n```\n\nSelezioniamo solo trial corretti:\n\n```{r, echo=FALSE}\nlibrary(knitr)\n\ndf_go_acc <- df_go[df_go$acc == 1 & df_go$identity == \"go\", ]\n\ng <- table(df_go_acc$id_subj, df_go_acc$block_order)\n\n# Prendi head e tail\ndx <- head(g)\ngx <- tail(g)\n\n# Costruzione tabella affiancata senza duplicazioni\ntabella_affiancata_2 <- cbind(\n  ID_CNTRL = rownames(dx),\n  dx,\n  ID_HSAM = rownames(gx),\n  gx\n)\n\n# Stampa la tabella\nkable(tabella_affiancata_2,\n      caption = \" trial per CNTRL (head) e HSAM (tail)\",\n      align = rep(\"c\", ncol(tabella_affiancata)))\n\n\n\n\n\n```\n\nCNTRL_13 deve essere escluso perchè ha sbagliato tutti i trial eccetto 1.\n\n```{r, echo=FALSE}\nc13<-df_go_acc[df_go_acc$id_subj== \"CNTRL13\",]\n\ntable(c13$id_subj, c13$block_order)\n\ndf_go_acc <-df_go_acc[!df_go_acc$id_subj %in% c(\"CNTRL13\"), ]\n#controllo\n\ndf_go_acc$ordine<-ifelse(df_go_acc$block_order==\"self-first\", \"TU\",\"SCONOSCIUTO\")\n\n```\n\nEliminiamo adesso RT sotto e sopra 3 sd media ciascun partecipante e condizione:\n\n```{r, echo=FALSE}\n\nsoggetti<-unique(df_go_acc$id_subj)\nordine<-unique(df_go_acc$block_order)\nn_print <- 0\nmax_print <- 10 \n\ndf_go_pulito<-data.frame()\nnumero_totale_out<-0\nfor(s in soggetti){\n  for(i in ordine){\n    df_tr<-df_go_acc[df_go_acc$id_subj==s & df_go_acc$block_order==i,]\n    media<-mean(df_tr$rt,na.rm=T)\n    ds<-sd(df_tr$rt,na.rm=T)\n    lower<-media-3*ds\n    high<-media+3*ds\n    \n    df_clean <- df_tr[df_tr$rt >= lower & df_tr$rt <= high, ]\n    n_out<-nrow(df_tr) - nrow(df_clean)\n    numero_totale_out <- numero_totale_out + n_out\n  \n    \n     # stampa solo i primi `max_print` messaggi\n    if (n_out > 0 && n_print < max_print) {\n      cat(\"Soggetto\", s, \"- Blocco\", i, \": eliminati\", n_out, \"outlier\\n\")\n      n_print <- n_print + 1\n    }\n    \n    \n    \n    df_go_pulito <-  rbind(df_go_pulito,df_clean)\n    }\n  \n}\ncat(head(\"Totale outlier eliminati:\", numero_totale_out, \"\\n\"))\ndf_go_pulito$block_order<-NULL\n\n```\n\nMediamente è stata eliminata una osservazione per soggetto.\n\n```{r, echo=FALSE}\n\n\n# # Calcola media e sd\n media <- tapply(df_go_pulito$rt, df_go_pulito$ordine, mean)\n dev_std <- tapply(df_go_pulito$rt, df_go_pulito$ordine, sd)\n# \n# # Arrotonda a una cifra decimale\n media <- round(media, 3)\n dev_std <- round(dev_std, 3)\n# # Crea tabella\n tabella_go <- data.frame(\n   Condizione = names(media),\n   Media_RT = as.numeric(media),\n   SD_RT = as.numeric(dev_std),\n   row.names = NULL\n )\n#  Visualizza con knitr::kable\n knitr::kable(tabella_go)\n# \n\ndf_go_hsam<-subset(df_go_pulito,df_go_pulito$group==\"HSAM\")\nmedia_go_hsam<-tapply(df_go_hsam$rt,df_go_hsam$ordine,mean)\nsd_go_hsam<-tapply(df_go_hsam$rt,df_go_hsam$ordine,sd)\n\nmedia_go_hsam<-round(media_go_hsam,3)\nsd_go_hsam <- round(sd_go_hsam, 3)\n\ntabella_go_hsam <- data.frame(\n  Condizione_HSAM = names(media_go_hsam),\n  Media_RT_HSAM = as.numeric(media_go_hsam),\n  SD_RT_HSAM = as.numeric(sd_go_hsam),\n  row.names = NULL\n)\n\nknitr::kable(tabella_go_hsam)\n\ndf_go_cntrl<-subset(df_go_pulito,df_go_pulito$group==\"CTRL\")\nmedia_go_cntrl<-tapply(df_go_cntrl$rt,df_go_cntrl$ordine,mean)\nsd_go_cntrl<-tapply(df_go_cntrl$rt,df_go_cntrl$ordine,sd)\n\nmedia_go_cntrl<-round(media_go_cntrl,3)\nsd_go_cntrl <- round(sd_go_cntrl, 3)\n\ntabella_go_cntrl <- data.frame(\n  Condizione_CNTRL = names(media_go_cntrl),\n  Media_RT_CNTRL = as.numeric(media_go_cntrl),\n  SD_RT_CNTRL = as.numeric(sd_go_cntrl),\n  row.names = NULL\n)\n\nknitr::kable(tabella_go_cntrl)\n \n\n```\n\nVisualizziamo gli RT delle due condizioni\n\n```{r, echo=FALSE}\n#grafico\nlibrary(ggplot2)\n\nggplot(df_go_acc, aes(x = rt, fill = ordine, color = ordine)) +\n  geom_density(alpha = 0.4) +\n  scale_fill_manual(values = c(\"TU\" = \"cyan\", \"SCONOSCIUTO\" = \"salmon\")) +\n  scale_color_manual(values = c(\"TU\" = \"cyan4\", \"SCONOSCIUTO\" = \"red3\")) +\n  labs(\n    x = \"RT\",\n    y = \"Densità\",\n    fill = NULL,\n    color = NULL,\n    title = \"RT Go-TU vs Go-SCONOSCIUTO\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    legend.position = \"right\"\n  )\n\n```\n\n```{r,include=FALSE}\ndf_go_pulito$ordine <- factor(df_go_pulito$ordine, levels = c(\"SCONOSCIUTO\", \"TU\"))\ndf_go_pulito$group  <- factor(df_go_pulito$group,  levels = c(\"CTRL\", \"HSAM\"))\nlibrary(brms)\n\nform<-bf(rt~ordine*group + (1+ordine|id_subj),\n         family = Gamma(link = \"log\"))\n\n\nmyPRIORS <- c(\n  set_prior(\"student_t(3, 0, 1)\", class = \"Intercept\"),\n  \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU\"),\n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"groupHSAM\"),\n  #set_prior( paste0(\"student_t(3, 0, .0055)\"), class = \"b\", \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU:groupHSAM\"),\n  set_prior( paste0(\"student_t(3, 0, 1)\"), class = \"sd\" ),\n  set_prior(paste0(\"gamma(17, 34)\"), class = \"shape\"))\n\n# Fit solo se non esiste già\nif (!file.exists(\"fit_go_bayes\")) {\n  fit_bayes <- brm(\n    formula = form,\n    data = df_go_pulito,\n    prior = myPRIORS,\n    chains = 4,\n    cores = parallel::detectCores(),\n    iter = 4000,\n    warmup = 1000,\n    seed = 1,\n    control = list(adapt_delta = 0.99)\n  )\n  saveRDS(fit_bayes, file = \"fit_go_bayes.rds\")\n} else {\n  fit_bayes <- readRDS(\"fit_go_bayes\")\n}\n\n```\n\nAdesso fittiamo il modello:\n\n```{r, eval=FALSE, echo=TRUE}\n\nform<-bf(rt~ordine*group + (1+ordine|id_subj),\n         family = Gamma(link = \"log\"))\n\nmyPRIORS <- c(\n  set_prior(\"student_t(3, 0, 1)\", class = \"Intercept\"),\n  \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU\"),\n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"groupHSAM\"),\n  #set_prior( paste0(\"student_t(3, 0, .0055)\"), class = \"b\", \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU:groupHSAM\"),\n  set_prior( paste0(\"student_t(3, 0, 1)\"), class = \"sd\" ),\n  set_prior(paste0(\"gamma(17, 34)\"), class = \"shape\"))\n\n\nfit_bayes<- brm(\n  formula = form,\n  data = df_go_pulito,\n  prior = myPRIORS,\n  chains = 4,\n  cores = parallel::detectCores(),\n  iter = 4000,\n  warmup = 1000,\n  seed = 1,\n  control = list(adapt_delta = 0.99)\n)\n\n```\n\n```{r}\nsummary(fit_bayes, prob=.9)\npp_check(fit_bayes, ndraws = 100)\nposteriori <- as.data.frame(fit_bayes)\nb3 <- posteriori$`b_ordineTU:groupHSAM`\nb1<- posteriori$`b_ordineTU`\n```\n\nIl posterior predictive check mostra che il modello riesce a riprodurre bene i dati osservati. Osservando i parametri possiamo vedere che B1, ha una stima negativa pari a −0.04, con un intervallo di credibilità al 90% che va da −0.07 a −0.01. Data la posterior (figura in basso), è possibile calcolare la probabilità a posteriori che il parametro sia negativo o che sia postivo.\n\n```{r}\npost_b1_go<-plot(fit_bayes,variable=\"b_ordineTU\")\narea_pos_b1<-mean(b1>0)\n\narea_neg_b1<-mean(b1<0)\n\n```\n\nLa probabilità che sia negativo è di:\n\n```{r}\narea_neg_b1\n\n```\n\nMentre la prob. a posteriori che sia positivo è di:\n\n```{r}\narea_pos_b1\n```\n\nSulla base di queste informazioni possiamo dichiarare che date le nostre posterior, è estremamente più probabile che, i partecipanti del gruppo di controllo rispondano più rapidamente nella condizione TU rispetto a quella SCONOSCIUTO.\n\nAnalogamente il parametro B3 di interazione, mostra una stima positiva di 0.03, ma l’intervallo di credibilità comprende lo zero (da −0.01 a 0.08). Andando a vedere la posterior (grafico sotto) si può poi calcolare la probabilità a posteriori che il parametro sia dentro l'intervallo nullo di +-10ms, e la probabilità che sia positivo o negativo.\n\n```{r}\npost_b3_go<-plot(fit_bayes, pars=\"ordineTU:groupHSAM\")\n\narea_pos_b3<-mean(b3>0)\n\narea_neg_b3<-mean(b3<0)\n\n```\n\nLa probabilità che B3 sia negativo è di:\n\n```{r,echo: false}\narea_neg_b3\n```\n\nMentre la prob. a posteriori che B3 sia positivo è di:\n\n```{r}\narea_pos_b3\n```\n\nL'intervallo nullo (NI) di B3 di+-10ms è compreso tra \\[-0.020 ; 0.020\\] e la prob a posteriori che il parametro caschi in tale intervallo è di:\n\n```{r}\narea_NI <- mean(b3 > -0.020 & b3 <0.020)\narea_NI\n```\n\nPer B3 avevamo scelto come prior una student_t(3, 0, .08). La prob. a priori che B3 si trovasse nel NI era di\n\n```{r}\n# Parametri della prior\ndf <- 3\nlocation <- 0\nscale <- 0.08\n\n# Intervallo nullo\nlower <- -0.02\nupper <-  0.02\n\n# Calcola la probabilità che beta3 cada nel ROPE\nprob_in_rope <- pt((upper - location)/scale, df) - pt((lower - location)/scale, df)\nprob_in_rope\n\n```\n\nQuindi possiamo concludere che aggiornando le prior con i dati raccolti, la prob. che B3 cada nel NI è aumentata di\n\n```{r}\narea_NI-prob_in_rope \n```\n\nI dati hanno *aumentato* l'evidenza a favore dell'effetto nullo rispetto alla prior.\n\nConcludendo, Il parametro di interazione β₃ presenta una stima centrale positiva di 0.03, suggerendo che il vantaggio per gli stimoli associati al sé (“TU”) potrebbe essere leggermente più marcato nel gruppo HSAM rispetto ai controlli. Tuttavia, l’intervallo di credibilità al 90% \\[−0.01 ; 0.08\\] include lo zero, indicando incertezza sull’effettiva direzione e consistenza dell’effetto.\n\nL'analisi della distribuzione a posteriori mostra che:\n\n-   La probabilità che β₃ sia positivo è 89.1%, mentre quella che sia negativo è 10.9%.\n\n-   La probabilità che β₃ cada nel \"null interval\" (NI) di ±10ms (cioè un effetto trascurabile) è 27.9%.\n\n-   A confronto, la probabilità a priori che β₃ fosse nel NI era 18.1%, per cui i dati hanno lievemente aumentato l’evidenza a favore di un effetto nullo, con un incremento del +9.7% rispetto alla prior.\n\n    Il fatto che quasi un terzo della distribuzione a posteriori cada nel NI suggerisce che non vi sia sufficiente evidenza per affermare un effetto differenziale tra i gruppi.\n\n```{r}\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Calcolo densità\ndens <- density(b3)\ndf_dens <- data.frame(x = dens$x, y = dens$y)\n\n# Intervallo nullo (NI: ±0.02)\ndf_null <- df_dens %>% filter(x > -0.02 & x < 0.02)\n\n# Intervallo positivo (β₃ > 0)\ndf_pos <- df_dens %>% filter(x > 0)\n\n# Plot\nggplot(df_dens, aes(x = x, y = y)) +\n  geom_area(data = df_pos, aes(x = x, y = y), fill = \"lightblue\", alpha = 0.5) +\n  geom_area(data = df_null, aes(x = x, y = y), fill = \"red\", alpha = 0.6) +\n  geom_line(color = \"black\", size = 0.6) +\n  geom_vline(xintercept = 0, linetype = \"dotted\", color = \"grey30\") +\n\n  # Etichetta area nulla: spostata a sinistra (x = -0.03)\n  annotate(\"label\", x = -0.03, y = max(df_dens$y) + 0.8,\n           label = paste0(\"P(-0.02 < β3 < 0.02) = \", round(area_NI, 3)),\n           fill = \"red\", color = \"white\", size = 4, label.size = NA) +\n\n  # Etichetta area positiva: spostata più a sinistra (x = 0.07)\n  annotate(\"label\", x = 0.07, y = max(df_dens$y) + 0.8,\n           label = paste0(\"P(β3 > 0) = \", round(area_pos_b3, 3)),\n           fill = \"lightblue\", color = \"black\", size = 4, label.size = NA) +\n\n  labs(title = expression(\"Distribuzione a Posteriori di \" * beta[3]),\n       x = expression(beta[3] * \" (interazione TU × Gruppo)\"),\n       y = \"Densità\") +\n  theme_minimal(base_size = 14) +\n  coord_cartesian(ylim = c(0, max(df_dens$y) + 1.5))\n\n\n```\n\nHo fittato anche il modello frequentista per vedere eventuale convergenze/divergenze:\n\n```{r}\n\nlibrary(glmmTMB)\n\nif (!file.exists(\"fit_gamma_freq\")) {\n  fit_gamma <- glmmTMB(\n  rt ~ ordine * group + (1 + ordine | id_subj),\n  data = df_go_pulito,\n  family = Gamma(link = \"log\")\n)\n  saveRDS(fit_bayes, file = \"fit_gamma_freq.rds\")\n} else {\n  fit_gamma <- readRDS(\"fit_gamma_freq\")\n}\nsummary(fit_gamma)\n```\n\n::: {style=\"display: flex; justify-content: space-between; margin-top: 2em;\"}\n<a href=\"analisi_matching.html\" class=\"btn btn-outline-secondary\">← Matching Task</a> <a href=\"power_go_nogo.html\" class=\"btn btn-primary\">Power Analysis →</a>\n:::\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)\n```\n\n### Pre-processing, data cleaning\n\nHo applicato una procedura simile a quella del dataframe del matching task, selezionando solo trial eseguiti correttamente (accuratezza=1) della condizione go. Inoltre ho escluso tempi di reazione estremi, definiti come valori oltre ±3 deviazioni standard dalla media per ciascun partecipante e condizione.\n\n```{r, echo=FALSE}\nlibrary(knitr)\n\ndf_go <- read.csv(\"C:/Users/39348/Desktop/DATI/go_unificato.csv\", stringsAsFactors = FALSE)\nx <- table(df_go$id_subj, df_go$block_order)\n\n# Prendi head e tail\nhx <- head(x)\ntx <- tail(x)\n\n# Costruzione tabella affiancata senza duplicazioni\ntabella_affiancata <- cbind(\n  ID_CNTRL = rownames(hx),\n  hx,\n  ID_HSAM = rownames(tx),\n  tx\n)\n\n# Stampa la tabella\nkable(tabella_affiancata,\n      caption = \" trial per CNTRL (head) e HSAM (tail)\",\n      align = rep(\"c\", ncol(tabella_affiancata)))\n\n```\n\nSelezioniamo solo trial corretti:\n\n```{r, echo=FALSE}\nlibrary(knitr)\n\ndf_go_acc <- df_go[df_go$acc == 1 & df_go$identity == \"go\", ]\n\ng <- table(df_go_acc$id_subj, df_go_acc$block_order)\n\n# Prendi head e tail\ndx <- head(g)\ngx <- tail(g)\n\n# Costruzione tabella affiancata senza duplicazioni\ntabella_affiancata_2 <- cbind(\n  ID_CNTRL = rownames(dx),\n  dx,\n  ID_HSAM = rownames(gx),\n  gx\n)\n\n# Stampa la tabella\nkable(tabella_affiancata_2,\n      caption = \" trial per CNTRL (head) e HSAM (tail)\",\n      align = rep(\"c\", ncol(tabella_affiancata)))\n\n\n\n\n\n```\n\nCNTRL_13 deve essere escluso perchè ha sbagliato tutti i trial eccetto 1.\n\n```{r, echo=FALSE}\nc13<-df_go_acc[df_go_acc$id_subj== \"CNTRL13\",]\n\ntable(c13$id_subj, c13$block_order)\n\ndf_go_acc <-df_go_acc[!df_go_acc$id_subj %in% c(\"CNTRL13\"), ]\n#controllo\n\ndf_go_acc$ordine<-ifelse(df_go_acc$block_order==\"self-first\", \"TU\",\"SCONOSCIUTO\")\n\n```\n\nEliminiamo adesso RT sotto e sopra 3 sd media ciascun partecipante e condizione:\n\n```{r, echo=FALSE}\n\nsoggetti<-unique(df_go_acc$id_subj)\nordine<-unique(df_go_acc$block_order)\nn_print <- 0\nmax_print <- 10 \n\ndf_go_pulito<-data.frame()\nnumero_totale_out<-0\nfor(s in soggetti){\n  for(i in ordine){\n    df_tr<-df_go_acc[df_go_acc$id_subj==s & df_go_acc$block_order==i,]\n    media<-mean(df_tr$rt,na.rm=T)\n    ds<-sd(df_tr$rt,na.rm=T)\n    lower<-media-3*ds\n    high<-media+3*ds\n    \n    df_clean <- df_tr[df_tr$rt >= lower & df_tr$rt <= high, ]\n    n_out<-nrow(df_tr) - nrow(df_clean)\n    numero_totale_out <- numero_totale_out + n_out\n  \n    \n     # stampa solo i primi `max_print` messaggi\n    if (n_out > 0 && n_print < max_print) {\n      cat(\"Soggetto\", s, \"- Blocco\", i, \": eliminati\", n_out, \"outlier\\n\")\n      n_print <- n_print + 1\n    }\n    \n    \n    \n    df_go_pulito <-  rbind(df_go_pulito,df_clean)\n    }\n  \n}\ncat(head(\"Totale outlier eliminati:\", numero_totale_out, \"\\n\"))\ndf_go_pulito$block_order<-NULL\n\n```\n\nMediamente è stata eliminata una osservazione per soggetto.\n\n```{r, echo=FALSE}\n\n\n# # Calcola media e sd\n media <- tapply(df_go_pulito$rt, df_go_pulito$ordine, mean)\n dev_std <- tapply(df_go_pulito$rt, df_go_pulito$ordine, sd)\n# \n# # Arrotonda a una cifra decimale\n media <- round(media, 3)\n dev_std <- round(dev_std, 3)\n# # Crea tabella\n tabella_go <- data.frame(\n   Condizione = names(media),\n   Media_RT = as.numeric(media),\n   SD_RT = as.numeric(dev_std),\n   row.names = NULL\n )\n#  Visualizza con knitr::kable\n knitr::kable(tabella_go)\n# \n\ndf_go_hsam<-subset(df_go_pulito,df_go_pulito$group==\"HSAM\")\nmedia_go_hsam<-tapply(df_go_hsam$rt,df_go_hsam$ordine,mean)\nsd_go_hsam<-tapply(df_go_hsam$rt,df_go_hsam$ordine,sd)\n\nmedia_go_hsam<-round(media_go_hsam,3)\nsd_go_hsam <- round(sd_go_hsam, 3)\n\ntabella_go_hsam <- data.frame(\n  Condizione_HSAM = names(media_go_hsam),\n  Media_RT_HSAM = as.numeric(media_go_hsam),\n  SD_RT_HSAM = as.numeric(sd_go_hsam),\n  row.names = NULL\n)\n\nknitr::kable(tabella_go_hsam)\n\ndf_go_cntrl<-subset(df_go_pulito,df_go_pulito$group==\"CTRL\")\nmedia_go_cntrl<-tapply(df_go_cntrl$rt,df_go_cntrl$ordine,mean)\nsd_go_cntrl<-tapply(df_go_cntrl$rt,df_go_cntrl$ordine,sd)\n\nmedia_go_cntrl<-round(media_go_cntrl,3)\nsd_go_cntrl <- round(sd_go_cntrl, 3)\n\ntabella_go_cntrl <- data.frame(\n  Condizione_CNTRL = names(media_go_cntrl),\n  Media_RT_CNTRL = as.numeric(media_go_cntrl),\n  SD_RT_CNTRL = as.numeric(sd_go_cntrl),\n  row.names = NULL\n)\n\nknitr::kable(tabella_go_cntrl)\n \n\n```\n\nVisualizziamo gli RT delle due condizioni\n\n```{r, echo=FALSE}\n#grafico\nlibrary(ggplot2)\n\nggplot(df_go_acc, aes(x = rt, fill = ordine, color = ordine)) +\n  geom_density(alpha = 0.4) +\n  scale_fill_manual(values = c(\"TU\" = \"cyan\", \"SCONOSCIUTO\" = \"salmon\")) +\n  scale_color_manual(values = c(\"TU\" = \"cyan4\", \"SCONOSCIUTO\" = \"red3\")) +\n  labs(\n    x = \"RT\",\n    y = \"Densità\",\n    fill = NULL,\n    color = NULL,\n    title = \"RT Go-TU vs Go-SCONOSCIUTO\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    legend.position = \"right\"\n  )\n\n```\n\n```{r,include=FALSE}\ndf_go_pulito$ordine <- factor(df_go_pulito$ordine, levels = c(\"SCONOSCIUTO\", \"TU\"))\ndf_go_pulito$group  <- factor(df_go_pulito$group,  levels = c(\"CTRL\", \"HSAM\"))\nlibrary(brms)\n\nform<-bf(rt~ordine*group + (1+ordine|id_subj),\n         family = Gamma(link = \"log\"))\n\n\nmyPRIORS <- c(\n  set_prior(\"student_t(3, 0, 1)\", class = \"Intercept\"),\n  \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU\"),\n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"groupHSAM\"),\n  #set_prior( paste0(\"student_t(3, 0, .0055)\"), class = \"b\", \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU:groupHSAM\"),\n  set_prior( paste0(\"student_t(3, 0, 1)\"), class = \"sd\" ),\n  set_prior(paste0(\"gamma(17, 34)\"), class = \"shape\"))\n\n# Fit solo se non esiste già\nif (!file.exists(\"fit_go_bayes\")) {\n  fit_bayes <- brm(\n    formula = form,\n    data = df_go_pulito,\n    prior = myPRIORS,\n    chains = 4,\n    cores = parallel::detectCores(),\n    iter = 4000,\n    warmup = 1000,\n    seed = 1,\n    control = list(adapt_delta = 0.99)\n  )\n  saveRDS(fit_bayes, file = \"fit_go_bayes.rds\")\n} else {\n  fit_bayes <- readRDS(\"fit_go_bayes\")\n}\n\n```\n\nAdesso fittiamo il modello:\n\n```{r, eval=FALSE, echo=TRUE}\n\nform<-bf(rt~ordine*group + (1+ordine|id_subj),\n         family = Gamma(link = \"log\"))\n\nmyPRIORS <- c(\n  set_prior(\"student_t(3, 0, 1)\", class = \"Intercept\"),\n  \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU\"),\n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"groupHSAM\"),\n  #set_prior( paste0(\"student_t(3, 0, .0055)\"), class = \"b\", \n  set_prior( paste0(\"student_t(3, 0, .08)\"), class = \"b\", \n             coef = \"ordineTU:groupHSAM\"),\n  set_prior( paste0(\"student_t(3, 0, 1)\"), class = \"sd\" ),\n  set_prior(paste0(\"gamma(17, 34)\"), class = \"shape\"))\n\n\nfit_bayes<- brm(\n  formula = form,\n  data = df_go_pulito,\n  prior = myPRIORS,\n  chains = 4,\n  cores = parallel::detectCores(),\n  iter = 4000,\n  warmup = 1000,\n  seed = 1,\n  control = list(adapt_delta = 0.99)\n)\n\n```\n\n```{r}\nsummary(fit_bayes, prob=.9)\npp_check(fit_bayes, ndraws = 100)\nposteriori <- as.data.frame(fit_bayes)\nb3 <- posteriori$`b_ordineTU:groupHSAM`\nb1<- posteriori$`b_ordineTU`\n```\n\nIl posterior predictive check mostra che il modello riesce a riprodurre bene i dati osservati. Osservando i parametri possiamo vedere che B1, ha una stima negativa pari a −0.04, con un intervallo di credibilità al 90% che va da −0.07 a −0.01. Data la posterior (figura in basso), è possibile calcolare la probabilità a posteriori che il parametro sia negativo o che sia postivo.\n\n```{r}\npost_b1_go<-plot(fit_bayes,variable=\"b_ordineTU\")\narea_pos_b1<-mean(b1>0)\n\narea_neg_b1<-mean(b1<0)\n\n```\n\nLa probabilità che sia negativo è di:\n\n```{r}\narea_neg_b1\n\n```\n\nMentre la prob. a posteriori che sia positivo è di:\n\n```{r}\narea_pos_b1\n```\n\nSulla base di queste informazioni possiamo dichiarare che date le nostre posterior, è estremamente più probabile che, i partecipanti del gruppo di controllo rispondano più rapidamente nella condizione TU rispetto a quella SCONOSCIUTO.\n\nAnalogamente il parametro B3 di interazione, mostra una stima positiva di 0.03, ma l’intervallo di credibilità comprende lo zero (da −0.01 a 0.08). Andando a vedere la posterior (grafico sotto) si può poi calcolare la probabilità a posteriori che il parametro sia dentro l'intervallo nullo di +-10ms, e la probabilità che sia positivo o negativo.\n\n```{r}\npost_b3_go<-plot(fit_bayes, pars=\"ordineTU:groupHSAM\")\n\narea_pos_b3<-mean(b3>0)\n\narea_neg_b3<-mean(b3<0)\n\n```\n\nLa probabilità che B3 sia negativo è di:\n\n```{r,echo: false}\narea_neg_b3\n```\n\nMentre la prob. a posteriori che B3 sia positivo è di:\n\n```{r}\narea_pos_b3\n```\n\nL'intervallo nullo (NI) di B3 di+-10ms è compreso tra \\[-0.020 ; 0.020\\] e la prob a posteriori che il parametro caschi in tale intervallo è di:\n\n```{r}\narea_NI <- mean(b3 > -0.020 & b3 <0.020)\narea_NI\n```\n\nPer B3 avevamo scelto come prior una student_t(3, 0, .08). La prob. a priori che B3 si trovasse nel NI era di\n\n```{r}\n# Parametri della prior\ndf <- 3\nlocation <- 0\nscale <- 0.08\n\n# Intervallo nullo\nlower <- -0.02\nupper <-  0.02\n\n# Calcola la probabilità che beta3 cada nel ROPE\nprob_in_rope <- pt((upper - location)/scale, df) - pt((lower - location)/scale, df)\nprob_in_rope\n\n```\n\nQuindi possiamo concludere che aggiornando le prior con i dati raccolti, la prob. che B3 cada nel NI è aumentata di\n\n```{r}\narea_NI-prob_in_rope \n```\n\nI dati hanno *aumentato* l'evidenza a favore dell'effetto nullo rispetto alla prior.\n\nConcludendo, Il parametro di interazione β₃ presenta una stima centrale positiva di 0.03, suggerendo che il vantaggio per gli stimoli associati al sé (“TU”) potrebbe essere leggermente più marcato nel gruppo HSAM rispetto ai controlli. Tuttavia, l’intervallo di credibilità al 90% \\[−0.01 ; 0.08\\] include lo zero, indicando incertezza sull’effettiva direzione e consistenza dell’effetto.\n\nL'analisi della distribuzione a posteriori mostra che:\n\n-   La probabilità che β₃ sia positivo è 89.1%, mentre quella che sia negativo è 10.9%.\n\n-   La probabilità che β₃ cada nel \"null interval\" (NI) di ±10ms (cioè un effetto trascurabile) è 27.9%.\n\n-   A confronto, la probabilità a priori che β₃ fosse nel NI era 18.1%, per cui i dati hanno lievemente aumentato l’evidenza a favore di un effetto nullo, con un incremento del +9.7% rispetto alla prior.\n\n    Il fatto che quasi un terzo della distribuzione a posteriori cada nel NI suggerisce che non vi sia sufficiente evidenza per affermare un effetto differenziale tra i gruppi.\n\n```{r}\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Calcolo densità\ndens <- density(b3)\ndf_dens <- data.frame(x = dens$x, y = dens$y)\n\n# Intervallo nullo (NI: ±0.02)\ndf_null <- df_dens %>% filter(x > -0.02 & x < 0.02)\n\n# Intervallo positivo (β₃ > 0)\ndf_pos <- df_dens %>% filter(x > 0)\n\n# Plot\nggplot(df_dens, aes(x = x, y = y)) +\n  geom_area(data = df_pos, aes(x = x, y = y), fill = \"lightblue\", alpha = 0.5) +\n  geom_area(data = df_null, aes(x = x, y = y), fill = \"red\", alpha = 0.6) +\n  geom_line(color = \"black\", size = 0.6) +\n  geom_vline(xintercept = 0, linetype = \"dotted\", color = \"grey30\") +\n\n  # Etichetta area nulla: spostata a sinistra (x = -0.03)\n  annotate(\"label\", x = -0.03, y = max(df_dens$y) + 0.8,\n           label = paste0(\"P(-0.02 < β3 < 0.02) = \", round(area_NI, 3)),\n           fill = \"red\", color = \"white\", size = 4, label.size = NA) +\n\n  # Etichetta area positiva: spostata più a sinistra (x = 0.07)\n  annotate(\"label\", x = 0.07, y = max(df_dens$y) + 0.8,\n           label = paste0(\"P(β3 > 0) = \", round(area_pos_b3, 3)),\n           fill = \"lightblue\", color = \"black\", size = 4, label.size = NA) +\n\n  labs(title = expression(\"Distribuzione a Posteriori di \" * beta[3]),\n       x = expression(beta[3] * \" (interazione TU × Gruppo)\"),\n       y = \"Densità\") +\n  theme_minimal(base_size = 14) +\n  coord_cartesian(ylim = c(0, max(df_dens$y) + 1.5))\n\n\n```\n\nHo fittato anche il modello frequentista per vedere eventuale convergenze/divergenze:\n\n```{r}\n\nlibrary(glmmTMB)\n\nif (!file.exists(\"fit_gamma_freq\")) {\n  fit_gamma <- glmmTMB(\n  rt ~ ordine * group + (1 + ordine | id_subj),\n  data = df_go_pulito,\n  family = Gamma(link = \"log\")\n)\n  saveRDS(fit_bayes, file = \"fit_gamma_freq.rds\")\n} else {\n  fit_gamma <- readRDS(\"fit_gamma_freq\")\n}\nsummary(fit_gamma)\n```\n\n::: {style=\"display: flex; justify-content: space-between; margin-top: 2em;\"}\n<a href=\"analisi_matching.html\" class=\"btn btn-outline-secondary\">← Matching Task</a> <a href=\"power_go_nogo.html\" class=\"btn btn-primary\">Power Analysis →</a>\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"self-contained":true,"output-file":"analisi_go_nogo.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"flatly","title":"HSAM: Analisi Go-NoGo","author":"Lorenzo Atzeni","editor":"visual","code":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}