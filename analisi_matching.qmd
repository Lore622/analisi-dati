---
title: "HSAM: Analisi Matching Task"
author: "Lorenzo Atzeni"
format:
  html:
    code: false  
    theme: flatly
    self-contained: true
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

### Pre-processing, data cleaning

Ho creato un dataframe con solo trial eseguiti correttamente (accuratezza=1) della condizione matching. Inoltre ho escluso tempi di reazione estremi, definiti come valori oltre ±3 deviazioni standard dalla media per ciascun partecipante e condizione. Con questo criterio sono stati rimosse 16 osservazioni, meno di una per partecipante. Le tabelle seguenti riportano i tempi di reazione (RT) medi relativi alle due condizioni, rispettivamente indipendentemente dal gruppo (prima tabella) e distinti per ciascun gruppo (seconda e terza tabella).

```{r, echo=FALSE}
rm(list = ls())

df_m <- read.csv("matching_task_unificato.csv", stringsAsFactors = FALSE)
df <- df_m[df_m$acc == 1 & (df_m$identity == "matching SCONOSCIUTO" | df_m$identity == "matching TU"), ]
df$identity_label <- ifelse(df$identity == "matching TU", "TU", "SCONOSCIUTO")

pulizia <- function(df){
  df_cleaned <- data.frame()
  soggetti <- unique(df$id_subj)
  condizioni <- unique(df$identity_label)
  for (s in soggetti) {
    for (c in condizioni) {
      sottoinsieme <- df[df$id_subj == s & df$identity_label == c, ]
      if (nrow(sottoinsieme) == 0) next
      media_rt <- mean(sottoinsieme$rt, na.rm = TRUE)
      sd_rt <- sd(sottoinsieme$rt, na.rm = TRUE)
      lower <- media_rt - 3 * sd_rt
      upper <- media_rt + 3 * sd_rt
      sottoinsieme_pulito <- sottoinsieme[sottoinsieme$rt >= lower & sottoinsieme$rt <= upper, ]
      df_cleaned <- rbind(df_cleaned, sottoinsieme_pulito)
    }
  }
  return(df_cleaned)
}

df_pulito <- pulizia(df)
df_pulito$identity_label <- factor(df_pulito$identity_label, levels = c("SCONOSCIUTO", "TU"))
df_pulito$group <- factor(df_pulito$group, levels = c("CTRL", "HSAM"))
```

```{r}

# Calcola media e sd
media <- tapply(df_pulito$rt, df_pulito$identity_label, mean)
dev_std <- tapply(df_pulito$rt, df_pulito$identity_label, sd)

# Arrotonda a una cifra decimale
media <- round(media, 3)
dev_std <- round(dev_std, 3)
# Crea tabella
tabella <- data.frame(
  Condizione_Totale = names(media),
  Media_RT = as.numeric(media),
  SD_RT = as.numeric(dev_std),
  row.names = NULL
)

# Visualizza con knitr::kable
knitr::kable(tabella)


df_hsam<-subset(df_pulito,df_pulito$group=="HSAM",select=c(rt,id_subj,group,acc,identity_label))
media_hsam<-tapply(df_hsam$rt,df_hsam$identity_label,mean)
sd_hsam<-tapply(df_hsam$rt,df_hsam$identity_label,sd)

media_hsam<-round(media_hsam,3)
sd_hsam <- round(sd_hsam, 3)

tabella_hsam <- data.frame(
  Condizione_HSAM = names(media_hsam),
  Media_RT_HSAM = as.numeric(media_hsam),
  SD_RT_HSAM = as.numeric(sd_hsam),
  row.names = NULL
)

knitr::kable(tabella_hsam)

df_cntrl<-subset(df_pulito,df_pulito$group=="CTRL",select=c(rt,id_subj,group,acc,identity_label))
media_cntrl<-tapply(df_cntrl$rt,df_cntrl$identity_label,mean)
sd_cntrl<-tapply(df_cntrl$rt,df_cntrl$identity_label,sd)

media_cntrl<-round(media_cntrl,3)
sd_cntrl <- round(sd_cntrl, 3)

tabella_cntrl <- data.frame(
  Condizione_CNTRL = names(media_cntrl),
  Media_RT_CNTRL = as.numeric(media_cntrl),
  SD_RT_CNTRL = as.numeric(sd_cntrl),
  row.names = NULL
)

knitr::kable(tabella_cntrl)
```

```{r}
library(ggplot2)

# Mappa per etichetta leggibile
df_pulito$identity_label <- ifelse(df_pulito$identity == "matching TU", "TU", "SCONOSCIUTO")

# Grafico con densità sovrapposte
ggplot(df_pulito, aes(x = rt, fill = identity_label, color = identity_label)) +
  geom_density(alpha = 0.4) +
  scale_fill_manual(values = c("TU" = "cyan", "SCONOSCIUTO" = "salmon")) +
  scale_color_manual(values = c("TU" = "cyan4", "SCONOSCIUTO" = "red3")) +
  labs(
    x = "RT",
    y = "Densità",
    fill = NULL,
    color = NULL,
    title = "RT Matching TU vs SCONOSCIUTO"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")


# Filtra solo le prove TU
df_tu <- df_pulito[df_pulito$identity_label == "TU", ]

# Grafico: RT matching-TU confronto tra gruppi

ggplot(df_tu, aes(x = rt, fill = group, color = group)) +
  geom_density(alpha = 0.4) +
  scale_fill_manual(values = c("HSAM" = "steelblue", "CTRL" = "darkgrey")) +
  scale_color_manual(values = c("HSAM" = "steelblue4", "CTRL" = "darkgrey")) +
  labs(
    x = "RT",
    y = "Densità",
    fill = NULL,
    color = NULL,
    title = "RT Matching-TU: gruppo HSAM vs CNTRL"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

```

Adesso fittiamo il modello con le stesse prior usate per la power analisi

```{r,include=FALSE}
library(brms)

formula_brm <- bf(rt ~ identity_label * group + (1 + identity_label | id_subj), family = Gamma(link = "log"))

priori <- c(
  set_prior("student_t(3, 0, 1)", class = "Intercept"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "identity_labelTU"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "groupHSAM"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "identity_labelTU:groupHSAM"),
  set_prior("student_t(3, 0, 1)", class = "sd"),
  set_prior("gamma(17,17)", class = "shape")
)

if (!file.exists("fit_bayes_no_outlier.rds")) {
  fit_no_outlier <- brm(
    formula = formula_brm,
    data = df_pulito,
    prior = priori,
    chains = 4,
    cores = parallel::detectCores(),
    iter = 4000,
    warmup = 1000,
    seed = 1,
    control = list(adapt_delta = 0.99)
  )
  saveRDS(fit_no_outlier, file = "fit_bayes_no_outlier.rds")
} else {
  fit_no_outlier <- readRDS("fit_bayes_no_outlier.rds")
}

```

```{r, eval=FALSE, echo=TRUE}

formula_brm <- bf(rt ~ identity_label * group + (1 + identity_label | id_subj), family = Gamma(link = "log"))

priori <- c(
  set_prior("student_t(3, 0, 1)", class = "Intercept"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "identity_labelTU"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "groupHSAM"),
  set_prior("student_t(3, 0, 0.08)", class = "b", coef = "identity_labelTU:groupHSAM"),
  set_prior("student_t(3, 0, 1)", class = "sd"),
  set_prior("gamma(17,17)", class = "shape")
)

fit_no_outlier <- brm(
  formula = formula_brm,
  data = df_pulito,
  prior = priori,
  chains = 4,
  cores = parallel::detectCores(),
  iter = 4000,
  warmup = 1000,
  seed = 1,
  control = list(adapt_delta = 0.99)
)
```

```{r}
summary(fit_no_outlier, prob = 0.90)
pp_check(fit_no_outlier, ndraws = 100)
posteriori <- as.data.frame(fit_no_outlier)
b3 <- posteriori$`b_identity_labelTU:groupHSAM`
b1<- posteriori$`b_identity_labelTU`
```

Il posterior predictive check mostra che il modello riproduce correttamente i dati osservati. B1 ha un intervallo di credibilità al 90% interamente negativo che va da –0.29 a –0.17, evidenziando che i tempi di reazione sono inferiori per gli stimoli associati al sè nei controlli (Self-Prioritizing Effect).

```{r, echo=FALSE}
post_b1<-plot(fit_no_outlier, variable = "b_identity_labelTU")

```

Per Il coefficiente β3 di interazione l'intervallo di credibilità invece contiene lo zero. Tuttavia siccome abbiamo la prior del parametro possiamo fare considerazioni aggiuntive che vanno oltre la significatività o non significatività statistica.

```{r, echo=FALSE}
post_b3<-plot(fit_no_outlier, pars = "identity_labelTU:groupHSAM")

```

La probabilità a posteriori che b3 sia positivo:

```{r, echo=FALSE}
area_b3_positive <- mean(b3 > 0)
area_b3_positive
```

La probabilità a posteriori che b3 sia nell'area che avevamo definito target ovvero tra 50 e 100ms, (b3 \> -0.14 & b3 \< -0.07):

```{r, echo=FALSE}
area_target <- mean(b3 > -0.14 & b3 < -0.07)
area_target
```

La probabilità a posteriori che b3 cada nella ROPE, nel Null Intervall di +-10ms, (b3 \> -0.013 & b3 \< 0.013):

```{r, echo=FALSE}
area_b3_NI <- mean(b3 > -0.013 & b3 < 0.013)
area_b3_NI
```

```{r}
library(ggplot2)
library(dplyr)
dens <- density(b3)
df_dens <- data.frame(x = dens$x, y = dens$y)
df_target <- df_dens %>% filter(x > -0.14 & x < -0.07)
df_null <- df_dens %>% filter(x > -0.013 & x < 0.013)

ggplot(df_dens, aes(x = x, y = y)) +
  geom_area(data = df_target, aes(x = x, y = y), fill = "lightgreen", alpha = 0.8) +
  geom_area(data = df_null, aes(x = x, y = y), fill = "red", alpha = 0.6) +
  geom_line(color = "black", size = 0.6) +
  annotate("label", x = -0.18, y = max(df_dens$y) + 0.4,
           label = paste0("P(-0.14 < β3 < -0.07) = ", round(area_target, 3)),
           fill = "lightgreen", color = "black", size = 4, label.size = NA) +
  annotate("label", x = 0.045, y = max(df_dens$y) + 0.4,
           label = paste0("P(-0.013 < β3 < 0.013) = ", round(area_b3_NI, 3)),
           fill = "red", color = "white", size = 4, label.size = NA) +
  labs(title = expression("Posterior di " * beta[3] * " (interazione I × G)"),
       x = expression(beta[3]),
       y = "Densità") +
  theme_minimal(base_size = 14) +
  coord_cartesian(ylim = c(0, max(df_dens$y) + 1.5))
```

Concludendo, sebbene l’intervallo di credibilità al 90% per B3 includa lo zero, l’analisi a posteriori fornisce indicazioni aggiuntive. Solo il 5.7% della distribuzione cade in un intervallo definito nullo (ROPE ±10ms), mentre circa il 45% si colloca in un range compatibile con una differenza di 50–100 ms tra i gruppi nella condizione “TU”. La probabilità che l’effetto sia positivo è bassa (≈ 5%), suggerendo che, qualora esista una differenza, essa è plausibilmente a favore degli HSAM.

Complessivamente, pur in assenza di evidenza conclusiva, i dati suggeriscono una possibile accentuazione dello SPE nei soggetti HSAM. Tuttavia, data l’ampiezza dell’intervallo di credibilità e la sovrapposizione con la regione nulla, l’effetto va considerato incerto e potenzialmente meritevole di ulteriore approfondimento, specialmente in studi con maggiore potenza statistica.

Ho fatto anche analisi frequentista per vedere se i rislutati convergevano.

```{r, echo=FALSE}
# Carica libreria
library(glmmTMB)

# Verifica se esiste già il modello salvato
if (!file.exists("fit_glmmTMB_no_outlier.rds")) {
  # Rimuovi colonna match_id se presente
  if ("match_id" %in% colnames(df_pulito)) {
    df_pulito$match_id <- NULL
  }

  # Stima modello
  fit_gamma_no_outlier <- glmmTMB(
    rt ~ identity_label * group + (1 + identity_label | id_subj),
    data = df_pulito,
    family = Gamma(link = "log")
  )

  # Salva modello
  saveRDS(fit_gamma_no_outlier, file = "fit_glmmTMB_no_outlier.rds")
} else {
  fit_gamma_no_outlier <- readRDS("fit_glmmTMB_no_outlier.rds")
}

# Mostra il summary (senza mostrare il codice)
summary(fit_gamma_no_outlier)

```

B1 viene significativo con p=4.67e-13, b3 invece non risulta significativo.

::: {style="text-align: right; margin-top: 2em;"}
<a href="analisi_go_nogo.html" class="btn btn-primary">Pagina successiva →</a>
:::
