
rm(list=ls())
#log(mu)= b0+b1x+b2z+b3*x*z+e
#log(μ) = b0 + b1 * cond_c + b2 * gruppo_c + b3 * cond_c * gruppo_c

b0= -0.37 #780 ms
b1= -0.29 #log(0.80)ms #rt "TU" è in media l’83.7% del RT nella condizione "SCONOSCIUTO"
b2= -0.20 #log(mugruppo1/gruppo2) mediando per condizione quasi nullo
b3= -0.14
n=30
t=100


dat<-expand.grid(subj=1:n,trial=1:t)
dat<-dat[order(dat$subj,dat$trial),]
row.names(dat)<-NULL
head(dat)

#mettiamo i parametri
dat$b0<-rep(b0,times=nrow(dat))
dat$b1<-rep(b1,times=nrow(dat))
dat$b2<-rep(b2,times=nrow(dat))
dat$b3<-rep(b3,times=nrow(dat))

#mettiamo la condizione centrata tu sconosciuto
dat$cond<-ifelse(dat$trial<101,.5,-.5)
dat$gruppo<-ifelse(dat$subj<16,.5,-.5) #######  ERRORE!!!


#aggiunta intercetta e slope random
library(MASS)
# matrice di covarianza con correlazione 0.25
Sigma <- matrix(c(0.01, 0.0025,
                  0.0025, 0.01), nrow = 2)
rand_eff <- mvrnorm(n = n, mu = c(0, 0), Sigma = Sigma)
b0i <- rand_eff[, 1]
b1i <- rand_eff[, 2]

dat$b0i <- b0i[dat$subj]
dat$b1i <- b1i[dat$subj]

#tolgo colonna mu che non serve nel dat
#dat$mu <- NULL PER TOGLIERE COLONNA ASSEGNAGLI NULL

#simuliamo RT con una gamma:
 # sapendo che mu<-shape/rate

# for(i in 1:nrow(dat)){
#   dat$mu[i]=dat$b0[i]+dat$b1[i]*dat$cond[i]+dat$b2[i]*dat$gruppo[i]+dat$b3[i]*dat$cond[i]*dat$gruppo[i]
#   dat$mu[i]=exp(dat$mu[i]) 
#   }
dat$lp <- with(dat,b0 + b0i + (b1 + b1i)*cond+ b2*gruppo+ b3*cond*gruppo)
mu=exp(dat$lp)
shape=12
rate<-shape/mu

dat$y  <- rgamma(nrow(dat), shape = shape, scale = mu / shape)


hist(dat$y)
summary(dat$y)
# library(truncdist)
# dat$y <- vapply(1:nrow(dat), function(i) {
#   rtrunc(1, spec = "gamma", shape = shape, rate = rate[i], a = 300, b = 1500)
# }, numeric(1))


############################################################################
#prior predictive check!!

library(brms)

myPRIORS <- c(
  set_prior( paste0("student_t(3, 0, 1)"), class = "Intercept"), 
  set_prior( paste0("student_t(3, 0, .08)"), class = "b", 
             coef = "cond"),
  set_prior( paste0("student_t(3, 0, .08)"), class = "b", 
             coef = "gruppo"),
  #set_prior( paste0("student_t(3, 0, .0055)"), class = "b", 
  set_prior( paste0("student_t(3, 0, .08)"), class = "b", 
             coef = "cond:gruppo"),
  set_prior( "student_t(3, 0, 1)", class = "sd" ),
  set_prior("gamma(17,17)", class = "shape"))


form <- bf(
  y ~ cond * gruppo + (1 + cond | subj),
  family = Gamma(link = "log")
)


fit_prior <- brm(
  formula       = form,
  data          = dat,
  prior         = myPRIORS,
  sample_prior  = "only",   # <- nessun dato usato per aggiornare
  chains        = 4,
  iter          = 2000,
  cores         = 4,
  seed          = 123
)


summary(fit_prior)



pp_check(fit_prior, ndraws = 1000) + coord_cartesian(xlim = c(0, 1))



####################################################################








library(glmmTMB)
# si può scrivere anche cosi:
#y ~ 1+(1|subj)+ cond+ (cond | subj)+ cond*gruppo oppure:
fit <- glmmTMB(
  y ~ cond * gruppo + (1 + cond | subj),
  data = dat,
  family = Gamma(link = "log")
) #cond*gruppo codifica sia interazione che maina effetti
#(1 + cond | subj)= Ogni soggetto (subj) ha random intercepte  
#propria slope per cond 
#1+ effetto su intercetta
#cond effetto su slope poi | subj significa per ogni soggetto

summary(fit)


#prima guardiamo i residui 

library(DHARMa)
res <- simulateResiduals(fit)

plot(res)


# fixef(fit) → ti dà solo i coefficienti fissi
# 
# ranef(fit) → ti dà le stime degli effetti casuali
# 
# VarCorr(fit) → varianze e correlazioni degli effetti casuali

#coef(fit)$cond   # per vedere effetti fissi + casuali per soggetto



#CALCOLO POWER FREQUENTISTA
sample_size<-c(20,50,70,100,120,150)
n_sim <- 100
power_counter <- setNames(rep(0, length(sample_size)), sample_size)
#setNames fantastico  permette di creare un vettore 
#con nomi associati ai suoi elementi, in un colpo solo.
n_iter<-n_sim*length(sample_size)

#per debug controllare fit
result_df<- data.frame(
  sim = integer(),
  sample_size = integer(),
  estimate = numeric(),
  ci_low = numeric(),
  ci_high = numeric(),
  stringsAsFactors = FALSE
) 
##

for (i in 1:n_sim){
for(j in sample_size){
  
  b0= 6.672033 
  b1= -0.1776812 
  b2= -0.06331228 
  b3= -0.1391128
  n<-j
  t=200
  
  dat<-expand.grid(subj=1:n,trial=1:t)
  dat<-dat[order(dat$subj,dat$trial),]
  row.names(dat)<-NULL
  head(dat)
 
  dat$b0<-rep(b0,times=nrow(dat))
  dat$b1<-rep(b1,times=nrow(dat))
  dat$b2<-rep(b2,times=nrow(dat))
  dat$b3<-rep(b3,times=nrow(dat))
  
  dat$cond<-ifelse(dat$trial<101,.5,-.5)
  dat$gruppo<-ifelse(dat$subj<16,.5,-.5)
  
  b0i <- rnorm(n, 0, 0.1)     
  dat$b0i <- b0i[dat$subj]     
  
  b1i <- rnorm(n, 0, 0.1)
  dat$b1i <- b1i[dat$subj]

  dat$lp <- with(dat,b0 + b0i + (b1 + b1i)*cond+ b2*gruppo+ b3*cond*gruppo)
  mu=exp(dat$lp)
  shape=17
  rate<-shape/mu
  
  dat$y <- vapply(1:nrow(dat), function(i) {
    rtrunc(1, spec = "gamma", shape = shape, rate = rate[i], a = 300, b = 1500)
  }, numeric(1))
  
  # fittiamo e stimiamo b3
  fit_sim <- glmmTMB(
    y ~ cond * gruppo + (1 + cond | subj),
    data = dat,
    family = Gamma(link = "log")
  )
  #debug salviamo fit
  
  result_df <- rbind(result_df, data.frame(
    sim = i,
    sample_size = j,
    estimate = summary(fit_sim)$coefficients$cond["cond:gruppo", "Estimate"],
    ci_low = confint(fit_sim, parm = "cond:gruppo", level = 0.90)[1],
    ci_high = confint(fit_sim, parm = "cond:gruppo", level = 0.90)[2]
  ))
  
  # Estraiamo stima e errore standard di b3
  b3_power <- summary(fit_sim)$coefficients$cond["cond:gruppo", "Estimate"]
  se  <- summary(fit_sim)$coefficients$cond["cond:gruppo", "Std. Error"]
  ci_b3 <- confint(fit_sim, parm = "cond:gruppo", level = 0.90)
  ci_b3_low <- ci_b3[1]
  ci_b3_high <- ci_b3[2]
  if (ci_b3_low > 0 & ci_b3_high > 0 | ci_b3_low < 0 & ci_b3_high < 0){
    power_counter[as.character(j)] =  power_counter[as.character(j)]  + 1
    
    
  }
}
}

power_b3=power_counter/(n_sim)
power_b3

result_df

# dat |> 
#   filter(id %in% sample(id, 30)) |> 
#   select(lp, x, id) |> 
#   mutate(rt = exp(lp)) |> 
#   distinct() |> 
#   ggplot(aes(x = x, y = rt)) +
#   geom_line(aes(group = id))



